<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>

<title>1. Introduction</title>

<script type="text/javascript">
window.onload = function() {
  var imgs = document.getElementsByTagName('img'), i, img;
  for (i = 0; i < imgs.length; i++) {
    img = imgs[i];
    // center an image if it is the only element of its parent
    if (img.parentElement.childElementCount === 1)
      img.parentElement.style.textAlign = 'center';
  }
};
</script>

<!-- Styles for R syntax highlighter -->
<style type="text/css">
   pre .operator,
   pre .paren {
     color: rgb(104, 118, 135)
   }

   pre .literal {
     color: #990073
   }

   pre .number {
     color: #099;
   }

   pre .comment {
     color: #998;
     font-style: italic
   }

   pre .keyword {
     color: #900;
     font-weight: bold
   }

   pre .identifier {
     color: rgb(0, 0, 0);
   }

   pre .string {
     color: #d14;
   }
</style>

<!-- R syntax highlighter -->
<script type="text/javascript">
var hljs=new function(){function m(p){return p.replace(/&/gm,"&amp;").replace(/</gm,"&lt;")}function f(r,q,p){return RegExp(q,"m"+(r.cI?"i":"")+(p?"g":""))}function b(r){for(var p=0;p<r.childNodes.length;p++){var q=r.childNodes[p];if(q.nodeName=="CODE"){return q}if(!(q.nodeType==3&&q.nodeValue.match(/\s+/))){break}}}function h(t,s){var p="";for(var r=0;r<t.childNodes.length;r++){if(t.childNodes[r].nodeType==3){var q=t.childNodes[r].nodeValue;if(s){q=q.replace(/\n/g,"")}p+=q}else{if(t.childNodes[r].nodeName=="BR"){p+="\n"}else{p+=h(t.childNodes[r])}}}if(/MSIE [678]/.test(navigator.userAgent)){p=p.replace(/\r/g,"\n")}return p}function a(s){var r=s.className.split(/\s+/);r=r.concat(s.parentNode.className.split(/\s+/));for(var q=0;q<r.length;q++){var p=r[q].replace(/^language-/,"");if(e[p]){return p}}}function c(q){var p=[];(function(s,t){for(var r=0;r<s.childNodes.length;r++){if(s.childNodes[r].nodeType==3){t+=s.childNodes[r].nodeValue.length}else{if(s.childNodes[r].nodeName=="BR"){t+=1}else{if(s.childNodes[r].nodeType==1){p.push({event:"start",offset:t,node:s.childNodes[r]});t=arguments.callee(s.childNodes[r],t);p.push({event:"stop",offset:t,node:s.childNodes[r]})}}}}return t})(q,0);return p}function k(y,w,x){var q=0;var z="";var s=[];function u(){if(y.length&&w.length){if(y[0].offset!=w[0].offset){return(y[0].offset<w[0].offset)?y:w}else{return w[0].event=="start"?y:w}}else{return y.length?y:w}}function t(D){var A="<"+D.nodeName.toLowerCase();for(var B=0;B<D.attributes.length;B++){var C=D.attributes[B];A+=" "+C.nodeName.toLowerCase();if(C.value!==undefined&&C.value!==false&&C.value!==null){A+='="'+m(C.value)+'"'}}return A+">"}while(y.length||w.length){var v=u().splice(0,1)[0];z+=m(x.substr(q,v.offset-q));q=v.offset;if(v.event=="start"){z+=t(v.node);s.push(v.node)}else{if(v.event=="stop"){var p,r=s.length;do{r--;p=s[r];z+=("</"+p.nodeName.toLowerCase()+">")}while(p!=v.node);s.splice(r,1);while(r<s.length){z+=t(s[r]);r++}}}}return z+m(x.substr(q))}function j(){function q(x,y,v){if(x.compiled){return}var u;var s=[];if(x.k){x.lR=f(y,x.l||hljs.IR,true);for(var w in x.k){if(!x.k.hasOwnProperty(w)){continue}if(x.k[w] instanceof Object){u=x.k[w]}else{u=x.k;w="keyword"}for(var r in u){if(!u.hasOwnProperty(r)){continue}x.k[r]=[w,u[r]];s.push(r)}}}if(!v){if(x.bWK){x.b="\\b("+s.join("|")+")\\s"}x.bR=f(y,x.b?x.b:"\\B|\\b");if(!x.e&&!x.eW){x.e="\\B|\\b"}if(x.e){x.eR=f(y,x.e)}}if(x.i){x.iR=f(y,x.i)}if(x.r===undefined){x.r=1}if(!x.c){x.c=[]}x.compiled=true;for(var t=0;t<x.c.length;t++){if(x.c[t]=="self"){x.c[t]=x}q(x.c[t],y,false)}if(x.starts){q(x.starts,y,false)}}for(var p in e){if(!e.hasOwnProperty(p)){continue}q(e[p].dM,e[p],true)}}function d(B,C){if(!j.called){j();j.called=true}function q(r,M){for(var L=0;L<M.c.length;L++){if((M.c[L].bR.exec(r)||[null])[0]==r){return M.c[L]}}}function v(L,r){if(D[L].e&&D[L].eR.test(r)){return 1}if(D[L].eW){var M=v(L-1,r);return M?M+1:0}return 0}function w(r,L){return L.i&&L.iR.test(r)}function K(N,O){var M=[];for(var L=0;L<N.c.length;L++){M.push(N.c[L].b)}var r=D.length-1;do{if(D[r].e){M.push(D[r].e)}r--}while(D[r+1].eW);if(N.i){M.push(N.i)}return f(O,M.join("|"),true)}function p(M,L){var N=D[D.length-1];if(!N.t){N.t=K(N,E)}N.t.lastIndex=L;var r=N.t.exec(M);return r?[M.substr(L,r.index-L),r[0],false]:[M.substr(L),"",true]}function z(N,r){var L=E.cI?r[0].toLowerCase():r[0];var M=N.k[L];if(M&&M instanceof Array){return M}return false}function F(L,P){L=m(L);if(!P.k){return L}var r="";var O=0;P.lR.lastIndex=0;var M=P.lR.exec(L);while(M){r+=L.substr(O,M.index-O);var N=z(P,M);if(N){x+=N[1];r+='<span class="'+N[0]+'">'+M[0]+"</span>"}else{r+=M[0]}O=P.lR.lastIndex;M=P.lR.exec(L)}return r+L.substr(O,L.length-O)}function J(L,M){if(M.sL&&e[M.sL]){var r=d(M.sL,L);x+=r.keyword_count;return r.value}else{return F(L,M)}}function I(M,r){var L=M.cN?'<span class="'+M.cN+'">':"";if(M.rB){y+=L;M.buffer=""}else{if(M.eB){y+=m(r)+L;M.buffer=""}else{y+=L;M.buffer=r}}D.push(M);A+=M.r}function G(N,M,Q){var R=D[D.length-1];if(Q){y+=J(R.buffer+N,R);return false}var P=q(M,R);if(P){y+=J(R.buffer+N,R);I(P,M);return P.rB}var L=v(D.length-1,M);if(L){var O=R.cN?"</span>":"";if(R.rE){y+=J(R.buffer+N,R)+O}else{if(R.eE){y+=J(R.buffer+N,R)+O+m(M)}else{y+=J(R.buffer+N+M,R)+O}}while(L>1){O=D[D.length-2].cN?"</span>":"";y+=O;L--;D.length--}var r=D[D.length-1];D.length--;D[D.length-1].buffer="";if(r.starts){I(r.starts,"")}return R.rE}if(w(M,R)){throw"Illegal"}}var E=e[B];var D=[E.dM];var A=0;var x=0;var y="";try{var s,u=0;E.dM.buffer="";do{s=p(C,u);var t=G(s[0],s[1],s[2]);u+=s[0].length;if(!t){u+=s[1].length}}while(!s[2]);if(D.length>1){throw"Illegal"}return{r:A,keyword_count:x,value:y}}catch(H){if(H=="Illegal"){return{r:0,keyword_count:0,value:m(C)}}else{throw H}}}function g(t){var p={keyword_count:0,r:0,value:m(t)};var r=p;for(var q in e){if(!e.hasOwnProperty(q)){continue}var s=d(q,t);s.language=q;if(s.keyword_count+s.r>r.keyword_count+r.r){r=s}if(s.keyword_count+s.r>p.keyword_count+p.r){r=p;p=s}}if(r.language){p.second_best=r}return p}function i(r,q,p){if(q){r=r.replace(/^((<[^>]+>|\t)+)/gm,function(t,w,v,u){return w.replace(/\t/g,q)})}if(p){r=r.replace(/\n/g,"<br>")}return r}function n(t,w,r){var x=h(t,r);var v=a(t);var y,s;if(v){y=d(v,x)}else{return}var q=c(t);if(q.length){s=document.createElement("pre");s.innerHTML=y.value;y.value=k(q,c(s),x)}y.value=i(y.value,w,r);var u=t.className;if(!u.match("(\\s|^)(language-)?"+v+"(\\s|$)")){u=u?(u+" "+v):v}if(/MSIE [678]/.test(navigator.userAgent)&&t.tagName=="CODE"&&t.parentNode.tagName=="PRE"){s=t.parentNode;var p=document.createElement("div");p.innerHTML="<pre><code>"+y.value+"</code></pre>";t=p.firstChild.firstChild;p.firstChild.cN=s.cN;s.parentNode.replaceChild(p.firstChild,s)}else{t.innerHTML=y.value}t.className=u;t.result={language:v,kw:y.keyword_count,re:y.r};if(y.second_best){t.second_best={language:y.second_best.language,kw:y.second_best.keyword_count,re:y.second_best.r}}}function o(){if(o.called){return}o.called=true;var r=document.getElementsByTagName("pre");for(var p=0;p<r.length;p++){var q=b(r[p]);if(q){n(q,hljs.tabReplace)}}}function l(){if(window.addEventListener){window.addEventListener("DOMContentLoaded",o,false);window.addEventListener("load",o,false)}else{if(window.attachEvent){window.attachEvent("onload",o)}else{window.onload=o}}}var e={};this.LANGUAGES=e;this.highlight=d;this.highlightAuto=g;this.fixMarkup=i;this.highlightBlock=n;this.initHighlighting=o;this.initHighlightingOnLoad=l;this.IR="[a-zA-Z][a-zA-Z0-9_]*";this.UIR="[a-zA-Z_][a-zA-Z0-9_]*";this.NR="\\b\\d+(\\.\\d+)?";this.CNR="\\b(0[xX][a-fA-F0-9]+|(\\d+(\\.\\d*)?|\\.\\d+)([eE][-+]?\\d+)?)";this.BNR="\\b(0b[01]+)";this.RSR="!|!=|!==|%|%=|&|&&|&=|\\*|\\*=|\\+|\\+=|,|\\.|-|-=|/|/=|:|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|\\?|\\[|\\{|\\(|\\^|\\^=|\\||\\|=|\\|\\||~";this.ER="(?![\\s\\S])";this.BE={b:"\\\\.",r:0};this.ASM={cN:"string",b:"'",e:"'",i:"\\n",c:[this.BE],r:0};this.QSM={cN:"string",b:'"',e:'"',i:"\\n",c:[this.BE],r:0};this.CLCM={cN:"comment",b:"//",e:"$"};this.CBLCLM={cN:"comment",b:"/\\*",e:"\\*/"};this.HCM={cN:"comment",b:"#",e:"$"};this.NM={cN:"number",b:this.NR,r:0};this.CNM={cN:"number",b:this.CNR,r:0};this.BNM={cN:"number",b:this.BNR,r:0};this.inherit=function(r,s){var p={};for(var q in r){p[q]=r[q]}if(s){for(var q in s){p[q]=s[q]}}return p}}();hljs.LANGUAGES.cpp=function(){var a={keyword:{"false":1,"int":1,"float":1,"while":1,"private":1,"char":1,"catch":1,"export":1,virtual:1,operator:2,sizeof:2,dynamic_cast:2,typedef:2,const_cast:2,"const":1,struct:1,"for":1,static_cast:2,union:1,namespace:1,unsigned:1,"long":1,"throw":1,"volatile":2,"static":1,"protected":1,bool:1,template:1,mutable:1,"if":1,"public":1,friend:2,"do":1,"return":1,"goto":1,auto:1,"void":2,"enum":1,"else":1,"break":1,"new":1,extern:1,using:1,"true":1,"class":1,asm:1,"case":1,typeid:1,"short":1,reinterpret_cast:2,"default":1,"double":1,register:1,explicit:1,signed:1,typename:1,"try":1,"this":1,"switch":1,"continue":1,wchar_t:1,inline:1,"delete":1,alignof:1,char16_t:1,char32_t:1,constexpr:1,decltype:1,noexcept:1,nullptr:1,static_assert:1,thread_local:1,restrict:1,_Bool:1,complex:1},built_in:{std:1,string:1,cin:1,cout:1,cerr:1,clog:1,stringstream:1,istringstream:1,ostringstream:1,auto_ptr:1,deque:1,list:1,queue:1,stack:1,vector:1,map:1,set:1,bitset:1,multiset:1,multimap:1,unordered_set:1,unordered_map:1,unordered_multiset:1,unordered_multimap:1,array:1,shared_ptr:1}};return{dM:{k:a,i:"</",c:[hljs.CLCM,hljs.CBLCLM,hljs.QSM,{cN:"string",b:"'\\\\?.",e:"'",i:"."},{cN:"number",b:"\\b(\\d+(\\.\\d*)?|\\.\\d+)(u|U|l|L|ul|UL|f|F)"},hljs.CNM,{cN:"preprocessor",b:"#",e:"$"},{cN:"stl_container",b:"\\b(deque|list|queue|stack|vector|map|set|bitset|multiset|multimap|unordered_map|unordered_set|unordered_multiset|unordered_multimap|array)\\s*<",e:">",k:a,r:10,c:["self"]}]}}}();hljs.LANGUAGES.r={dM:{c:[hljs.HCM,{cN:"number",b:"\\b0[xX][0-9a-fA-F]+[Li]?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+(?:[eE][+\\-]?\\d*)?L\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\b\\d+\\.(?!\\d)(?:i\\b)?",e:hljs.IMMEDIATE_RE,r:1},{cN:"number",b:"\\b\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"number",b:"\\.\\d+(?:[eE][+\\-]?\\d*)?i?\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"keyword",b:"(?:tryCatch|library|setGeneric|setGroupGeneric)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\.",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\.\\.\\d+(?![\\w.])",e:hljs.IMMEDIATE_RE,r:10},{cN:"keyword",b:"\\b(?:function)",e:hljs.IMMEDIATE_RE,r:2},{cN:"keyword",b:"(?:if|in|break|next|repeat|else|for|return|switch|while|try|stop|warning|require|attach|detach|source|setMethod|setClass)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"literal",b:"(?:NA|NA_integer_|NA_real_|NA_character_|NA_complex_)\\b",e:hljs.IMMEDIATE_RE,r:10},{cN:"literal",b:"(?:NULL|TRUE|FALSE|T|F|Inf|NaN)\\b",e:hljs.IMMEDIATE_RE,r:1},{cN:"identifier",b:"[a-zA-Z.][a-zA-Z0-9._]*\\b",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"<\\-(?!\\s*\\d)",e:hljs.IMMEDIATE_RE,r:2},{cN:"operator",b:"\\->|<\\-",e:hljs.IMMEDIATE_RE,r:1},{cN:"operator",b:"%%|~",e:hljs.IMMEDIATE_RE},{cN:"operator",b:">=|<=|==|!=|\\|\\||&&|=|\\+|\\-|\\*|/|\\^|>|<|!|&|\\||\\$|:",e:hljs.IMMEDIATE_RE,r:0},{cN:"operator",b:"%",e:"%",i:"\\n",r:1},{cN:"identifier",b:"`",e:"`",r:0},{cN:"string",b:'"',e:'"',c:[hljs.BE],r:0},{cN:"string",b:"'",e:"'",c:[hljs.BE],r:0},{cN:"paren",b:"[[({\\])}]",e:hljs.IMMEDIATE_RE,r:0}]}};
hljs.initHighlightingOnLoad();
</script>



<style type="text/css">
body, td {
   font-family: sans-serif;
   background-color: white;
   font-size: 13px;
}

body {
  max-width: 800px;
  margin: auto;
  padding: 1em;
  line-height: 20px;
}

tt, code, pre {
   font-family: 'DejaVu Sans Mono', 'Droid Sans Mono', 'Lucida Console', Consolas, Monaco, monospace;
}

h1 {
   font-size:2.2em;
}

h2 {
   font-size:1.8em;
}

h3 {
   font-size:1.4em;
}

h4 {
   font-size:1.0em;
}

h5 {
   font-size:0.9em;
}

h6 {
   font-size:0.8em;
}

a:visited {
   color: rgb(50%, 0%, 50%);
}

pre, img {
  max-width: 100%;
}
pre {
  overflow-x: auto;
}
pre code {
   display: block; padding: 0.5em;
}

code {
  font-size: 92%;
  border: 1px solid #ccc;
}

code[class] {
  background-color: #F8F8F8;
}

table, td, th {
  border: none;
}

blockquote {
   color:#666666;
   margin:0;
   padding-left: 1em;
   border-left: 0.5em #EEE solid;
}

hr {
   height: 0px;
   border-bottom: none;
   border-top-width: thin;
   border-top-style: dotted;
   border-top-color: #999999;
}

@media print {
   * {
      background: transparent !important;
      color: black !important;
      filter:none !important;
      -ms-filter: none !important;
   }

   body {
      font-size:12pt;
      max-width:100%;
   }

   a, a:visited {
      text-decoration: underline;
   }

   hr {
      visibility: hidden;
      page-break-before: always;
   }

   pre, blockquote {
      padding-right: 1em;
      page-break-inside: avoid;
   }

   tr, img {
      page-break-inside: avoid;
   }

   img {
      max-width: 100% !important;
   }

   @page :left {
      margin: 15mm 20mm 15mm 10mm;
   }

   @page :right {
      margin: 15mm 10mm 15mm 20mm;
   }

   p, h2, h3 {
      orphans: 3; widows: 3;
   }

   h2, h3 {
      page-break-after: avoid;
   }
}
</style>



</head>

<body>
<h2>1. Introduction</h2>

<p><code>osmdata</code> is an R package for downloading and using data from OpenStreetMap
(<a href="www.openstreetmap.org/">OSM</a>).  OSM is a global open access mapping project,
which is free and open under the 
<a href="http://www.openstreetmap.org/copyright">ODbL licence</a> [@OpenStreetMap].  This
has many benefits, ensuring transparent data provenance and ownership, enabling
real-time evolution of the database and, by allowing anyone to contribute,
encouraging democratic decision making and citizen science
[@johnson_models_2017].  See the 
<a href="http://wiki.openstreetmap.org/wiki/Contribute_map_data">OSM wiki</a> to find out
how to contribute to the world&#39;s open geographical data commons. </p>

<p>Unlike the <a href="https://cran.r-project.org/package=OpenStreetMap"><code>OpenStreetMap</code></a>
package, which facilitates the download of raster tiles, <code>osmdata</code> provides
access to the vector data underlying OSM.</p>

<p><code>osmdata</code> can be installed from CRAN with</p>

<pre><code class="r">install.packages(&quot;osmdata&quot;)
</code></pre>

<p>and then loaded in the usual way:</p>

<pre><code class="r">library(osmdata)
</code></pre>

<pre><code>## Data (c) OpenStreetMap contributors, ODbL 1.0. http://www.openstreetmap.org/copyright
</code></pre>

<p>The development version of <code>osmdata</code> can be installed with the <code>devtools</code>
package using the following command:</p>

<pre><code class="r">devtools::install_github(&#39;osmdatar/osmdata&#39;)
</code></pre>

<p>This vignette also uses the <a href="https://github.com/tidyverse/magrittr"><code>magrittr</code></a> pipe, <code>%&gt;%</code>, for &#39;pipy&#39; workflows.</p>

<p><code>osmdata</code> uses the <a href="http://overpass-api.de"><code>overpass</code> API</a> to download
OpenStreetMap (OSM) data and can convert the results to either Simple Features
(typically of class <code>sf</code>) or Spatial objects (e.g. <code>SpatialPointsDataFrame</code>), as
defined by the packages <a href="https://cran.r-project.org/package=sf"><code>sf</code></a> and
<a href="https://cran.r-project.org/package=sp"><code>sp</code></a> packages respectively.</p>

<p><code>overpass</code> is a C++ library that serves OSM data over the web.  All <code>overpass</code>
queries begin with a bounding box, defined in <code>osmdata</code> with the function
<code>opq()</code>:</p>

<pre><code class="r">q &lt;- opq(bbox = c(51.1, 0.1, 51.2, 0.2))
</code></pre>

<p>Bounding boxes may also be defined by simply passing the name of a desired area</p>

<ul>
<li>if <code>bbox</code> is a text string <code>opq()</code> uses the helper function <code>getbb()</code> to
convert it into a bounding box:</li>
</ul>

<pre><code class="r">bb = getbb(&#39;Greater London, U.K.&#39;)
q &lt;- opq(bbox = bb)
</code></pre>

<p>Note that the text string is not case sensitive, and that you can avoid the
intermediate step of using <code>getbb()</code> by placing a text string directly into the
<code>bbox</code> argument of <code>opq()</code>:</p>

<pre><code class="r">identical(q, opq(bbox = &#39;greater london uk&#39;))
## TRUE
</code></pre>

<p>Note also that <code>getbb()</code> can return a data frame reporting multiple matches or
matrices representing bounding polygons of matches:</p>

<pre><code class="r">bb_df = getbb(place_name = &quot;london&quot;, format_out = &quot;data.frame&quot;)
bb_poly = getbb(place_name = &quot;london&quot;, format_out = &quot;polygon&quot;)
</code></pre>

<p>The <a href="www.overpass-api.de"><code>overpass API</code></a> only accepts simple rectangular
bounding boxes, and so data requested with a bounding polygon will actually be
all data within the corresponding bounding box, but such data may be
subsequently trimmed to within the polygon with the <code>trim_osmdata()</code> function,
demonstrated in the code immediately below.</p>

<p>Following the initial <code>opq()</code> call, <code>osmdata</code> queries are built by adding one or
more &#39;features&#39;, which are specified in terms of <code>key-value</code> pairs.  For
example, all paths, ways, and roads are designated in OSM with <code>key=highway</code>, so
that a query all motorways in greater London (UK) can be constructed as follows:</p>

<pre><code class="r">q &lt;- opq(bbox = &#39;greater london uk&#39;) %&gt;%
    add_osm_feature(key = &#39;highway&#39;, value = &#39;motorway&#39;)
</code></pre>

<p>All highways from within the polygonal boundary of Greater London can be
extracted with,</p>

<pre><code class="r">q &lt;- opq(bbox = &#39;greater london uk&#39;, format_out = &#39;polygon&#39;) %&gt;%
    add_osm_feature(key = &#39;highway&#39;, value = &#39;motorway&#39;) %&gt;%
    trim_osmdata ()
</code></pre>

<p>See <code>?time_osmdata()</code> for further ways to obtain polygonally bounded sets of OSM
data.</p>

<p>A detailed description of features is provided at the 
<a href="https://wiki.openstreetmap.org/wiki/Category:Keys">OSM wiki</a>, or the 
<code>osmdata</code> function <code>available_features()</code> can be used to retrive the
comprehensive list of feature keys currently used in OSM.</p>

<pre><code class="r">head (available_features ())
</code></pre>

<pre><code>## [1] &quot;4wd only&quot;  &quot;abandoned&quot; &quot;abutters&quot;  &quot;access&quot;    &quot;addr&quot;      &quot;addr:city&quot;
</code></pre>

<p>There are two primary <code>osmdata</code> functions for obtaining data from a query:
<code>osmdata_sf()</code> and <code>osmdata_sp()</code>, which return data in 
<a href="https://cran.r-project.org/package=sf">Simple Features (<code>sf</code>)</a>
and <a href="https://cran.r-project.org/package=sp">Spatial (<code>sp</code>)</a> formats,
respectively.</p>

<h2>2. The overpass API</h2>

<p>As mentioned, <code>osmdata</code> obtains OSM data from the 
<a href="www.overpass-api.de"><code>overpass API</code></a>, 
<a href="http://wiki.openstreetmap.org/wiki/Overpass_API">which is</a></p>

<blockquote>
<p>a read-only API that serves up custom selected parts of the OSM map data.</p>
</blockquote>

<p>The syntax of <code>overpass</code> queries is powerful yet hard to learn.  This
section briefly introduces the structure of <code>overpass</code> queries in order to help
construct more efficient and powerful queries.  Those wanting to skip straight
onto query construction in <code>osmdata</code> may safely jump ahead to the <a href="#query-example">query example
below</a>.</p>

<p><code>osmdata</code> simplifies queries so that OSM data can be extracted with very little
understanding of the <code>overpass</code> query syntax, although it is still possible to
submit arbitrarily complex <code>overpass</code>  queries via <code>osmdata</code>.  An excellent
place to explore <code>overpass</code> queries specifically and OSM data in general is the 
online interactive query builder at <a href="http://overpass-turbo.eu/">overpass-turbo</a>,
which includes a helpful corrector function for incorrectly formatted queries.
Examples of its functionality in action can be found on the 
<a href="http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_API_by_Example">OpenStreetMap wiki</a>,
with full details of the <code>overpass</code>
query language given in the 
<a href="http://wiki.openstreetmap.org/wiki/Overpass_API/Overpass_QL">Query Language Guide</a> 
as well as the 
<a href="http://wiki.openstreetmap.org/wiki/Overpass_API/Language_Guide">overpass API Language Guide</a>.</p>

<p>By default, <code>osmdata</code> sends queries to <code>http://overpass-api.de/api/interpreter</code>
but other servers can be used, thanks to functions that <em>get</em> and <em>set</em> the base
url:</p>

<pre><code class="r">get_overpass_url()
</code></pre>

<pre><code>## [1] &quot;http://overpass-api.de/api/interpreter&quot;
</code></pre>

<pre><code class="r">new_url &lt;- &quot;http://overpass.openstreetmap.ie/api/interpreter&quot;
</code></pre>

<pre><code class="r">set_overpass_url(new_url) # reset the base url (not run)
</code></pre>

<p><code>osmdata</code> queries are lists of class <code>overpass_query</code>. The actual query passed
to the <code>overpass API</code> with a query can be obtained with the function
<code>opq_string()</code>.  Applied to the preceding query, this function gives:</p>

<pre><code class="r">opq_string(q)
## [out:xml][timeout:25];
## (
##   node
##     [&quot;highway&quot;=&quot;motorway&quot;]
##     (51.2867602,-0.510375,51.6918741,0.3340155);
##   way  
##     [&quot;highway&quot;=&quot;motorway&quot;]
##     (51.2867602,-0.510375,51.6918741,0.3340155);
##   relation  
##     [&quot;highway&quot;=&quot;motorway&quot;]
##     (51.2867602,-0.510375,51.6918741,0.3340155);
## );
## (._;&gt;);out body;
</code></pre>

<p>The resultant output may be pasted directly into the 
<a href="http://overpass-turbo.eu/">overpass-turbo</a> online interactive query builder.
(The output of <code>opq_string</code> has been somewhat reformatted here to reflect
the format typically used in <code>overpass-turbo</code>.)</p>

<h3>2.1. osmdata queries</h3>

<p>As demonstrated above, an <code>osmdata</code> query begins by specifying a bounding box
with the function <code>opq()</code>, followed by specifying desired OSM features with
<code>add_feature()</code>.  </p>

<pre><code class="r">q &lt;- opq(bbox = &#39;Kunming, China&#39;) %&gt;%
    add_osm_feature(key = &#39;natural&#39;, value = &#39;water&#39;)
</code></pre>

<p>This query will request all natural water water bodies in Kunming, China. A
particular water body may be requested through appending a further call to
<code>add_osm_feature()</code>:</p>

<pre><code class="r">q &lt;- opq(bbox = &#39;Kunming, China&#39;) %&gt;%
    add_osm_feature(key = &#39;natural&#39;, value = &#39;water&#39;) %&gt;%
    add_osm_feature(key = &#39;name:en&#39;, value = &#39;Dian&#39;, value_exact = FALSE)
</code></pre>

<p>Each successive call to <code>add_osm_feature()</code> <strong>adds</strong> features to a query. This query
is thus a request for all bodies of natural water <strong>and</strong> those with English
names that include &#39;Dian&#39;. The requested data may be extracted through calling
one of the <code>osmdata_xml/sp/sf()</code> functions.</p>

<p>Single queries are always constructed through <strong>adding</strong> features, and therefore
correspond to logical <strong>AND</strong> operations: natural water bodies <strong>AND</strong> those
whose names include &#39;Dian&#39;.  The equivalent <strong>OR</strong> combination requires
extracting separate data sets and combining then with the inbuilt <code>c</code> operator
of <code>osmdata</code>. The following code demonstrates this with <code>osmdata_sf()</code>:</p>

<pre><code class="r">dat1 &lt;- opq(bbox = &#39;Kunming, China&#39;) %&gt;%
    add_osm_feature(key = &#39;natural&#39;, value = &#39;water&#39;) %&gt;%
    osmdata_sf ()
dat2 &lt;- opq(bbox = &#39;Kunming, China&#39;) %&gt;%
    add_osm_feature(key = &#39;name:en&#39;, value = &#39;Dian&#39;, value_exact = FALSE) %&gt;%
    osmdata_sf ()
dat &lt;- c (dat1, dat2)
</code></pre>

<p>The following code extracted numbers of objects returned in each case (where the
fourth-to-eighth items of an <code>osmdata</code> object are those containing the actual
spatial data)</p>

<pre><code class="r">unlist (lapply (dat1, nrow) [4:8])
unlist (lapply (dat2, nrow) [4:8])
unlist (lapply (dat, nrow) [4:8])
</code></pre>

<pre><code>##        osm_points         osm_lines      osm_polygons    osm_multilines 
##              7373                31               118                 0 
## osm_multipolygons 
##                10
</code></pre>

<pre><code>##        osm_points         osm_lines      osm_polygons    osm_multilines 
##              2254                30                 2                 0 
## osm_multipolygons 
##                 1
</code></pre>

<pre><code>##        osm_points         osm_lines      osm_polygons osm_multipolygons 
##              7590                46               119                10
</code></pre>

<p>The number of resultant objects is less than the sum of the individual
components because the <code>c</code> operator only combines unique objects. There are
thus, for example, 7,590 points corresponding to objects in Kunming, China that
are <strong>either</strong> natural waterbodies <strong>or</strong> that include &#39;Dian&#39; in their English
name.  Compare this with the result of the equivalent <code>AND</code> operation</p>

<pre><code class="r">unlist (lapply (osmdata_sf (q), nrow) [4:8])
</code></pre>

<pre><code>##        osm_points         osm_lines      osm_polygons    osm_multilines 
##              2029                15                 1                 0 
## osm_multipolygons 
##                 1
</code></pre>

<p>And there are, for example, the considerably lower number of 2,029 points
describing objects in Kunming that are <strong>both</strong> natural waterbodies <strong>and</strong> that
include &#39;Dian&#39; in their English name.</p>

<p>Each successive feature added with <code>add_feature()</code> is added to previous
features, so, for example, extending the previous query by an additional
<code>key-value</code> pair to:</p>

<p>Both <code>key</code> and <code>value</code> fields may be matched either exactly or approximately.
The previous query is repeated here for convenience:</p>

<pre><code class="r">q &lt;- opq(bbox = &#39;Kunming, China&#39;) %&gt;%
    add_osm_feature(key = &#39;natural&#39;, value = &#39;water&#39;) %&gt;%
    add_osm_feature(key = &#39;name:en&#39;, value = &#39;Dian&#39;, value_exact = FALSE)
</code></pre>

<p>In addtion to <code>value_exact</code>, <code>add_osm_feature</code> also offers the additional two
options of <code>key_exact</code> and <code>match_case</code>. The former functions just like
<code>value_exact</code>, but is applied to the specified <code>key</code> parameter, while
<code>match_case</code> (default <code>TRUE</code>) specifies whether case should also be matched.
These options allow the above query to be rewritten,</p>

<pre><code class="r">q &lt;- opq(bbox = &#39;Kunming, China&#39;) %&gt;%
    add_osm_feature(key = &#39;natural&#39;, value = &#39;water&#39;) %&gt;%
    add_osm_feature(key = &#39;name&#39;, value = &#39;dian&#39;, key_exact = FALSE,
                value_exact = FALSE, match_case = FALSE)
</code></pre>

<h3>3.2 Extracting <code>OSM</code> data from a query</h3>

<p>The primary <code>osmdata</code> functions <code>osmdata_sf()</code> or <code>osmdata_sp()</code> pass these
queries to <code>overpass</code> and return OSM data in corresponding <code>sf</code> or <code>sp</code> format,
respectively.  Both of these functions also accept direct <code>overpass</code> queries,
such as those produced by the <code>osmdata</code> function <code>opq_string()</code>, or copied
directly from the <a href="overpass-turbo.eu"><code>overpass-turbo</code> query builder</a>.</p>

<pre><code class="r">osmdata_sf(opq_string(q))
## Object of class &#39;osmdata&#39; with:
##                  $bbox :
##         $overpass_call : The call submitted to the overpass API
##             $timestamp : [ Thurs 5 May 2017 14:33:54 ]
##            $osm_points : &#39;sf&#39; Simple Features Collection with 360582 points
##            ...
</code></pre>

<p>Note that the result contains no value for <code>bbox</code>, because that information is
lost when the full <code>osmdata_query</code>, <code>q</code>, is converted to a string.
Nevertheless, the results of the two calls <code>osmdata_sf (opq_string (q))</code> and
<code>osmdata_sf (q)</code> differ only in the values of <code>bbox</code> and <code>timestamp</code>, while
returning otherwise identical data.</p>

<p>In summary, <code>osmdata</code> queries are generally simplified versions of potentially
more complex <code>overpass</code> queries, although arbitrarily complex <code>overpass</code> queries
may be passed directly to the primary <code>osmdata</code> functions.  As illustrated
above, <code>osmdata</code> queries are generally constructed through initiating a query
with <code>opq()</code>, and then specifying OSM features in terms of <code>key-value</code> pairs
with <code>add_osm_feature()</code>, along with judicious usage of the <code>key_exact</code>,
<code>value_exact</code>, and <code>match_case</code> parameters.</p>

<p>The simplest way to use <code>osmdata</code> is to simply request all data within a given
bounding box (warning - not intended to run):</p>

<pre><code class="r">q &lt;- opq(bbox = &#39;London City, U.K.&#39;)
lots_of_data &lt;- osmdata_sf(q)
</code></pre>

<p>Queries are, however, usually more useful when refined through using
<code>add_feature()</code>, which minimally requires a single <code>key</code> and returns all objects
specifying any value for that <code>key</code>: </p>

<pre><code class="r">not_so_much_data &lt;- opq(bbox = &#39;city of london uk&#39;) %&gt;%
    add_osm_feature(key = &#39;highway&#39;) %&gt;%
    add_osm_feature(key = &#39;name&#39;) %&gt;%
    osmdata_sf()
</code></pre>

<p><code>osmdata</code> will use that query to return all named highways within the requested
bounding box. Note that <code>key</code> specifications are requests for features which
must include those keys, yet most features will also include many other keys,
and thus <code>osmdata</code> objects generally list a large number of distinct keys, as
demonstrated below.</p>

<h3>2.2. Query example</h3>

<p>To appreciate query building in more concrete terms, let&#39;s imagine that we
wanted to find all cycle paths in Seville, Spain:</p>

<pre><code class="r">q1 &lt;- opq(&#39;Sevilla&#39;) %&gt;%
    add_osm_feature(key = &#39;highway&#39;, value = &#39;cycleway&#39;)
cway_sev &lt;- osmdata_sp(q1)
sp::plot(cway_sev$osm_lines)
</code></pre>

<p><img src="https://cloud.githubusercontent.com/assets/1825120/23708182/fba4ed96-040c-11e7-90cd-3274d394030a.png" alt=""/></p>

<p>Now imagine we want to make a more specific query that only extracts designated
cycleways or those which are bridges. Combining these into one query will return
only those that are designated cycleways <strong>AND</strong> that are bridges:</p>

<pre><code class="r">q2 &lt;- add_feature(q1, key = &#39;bicycle&#39;, value = &#39;designated&#39;)
des_bike &lt;- osmdata_sf(q2)
q3 &lt;- add_feature(q2, key = &#39;bridge&#39;, value = &#39;yes&#39;)
des_bike_and_bridge &lt;- osmdata_sf(q3)
nrow(des_bike_and_bridge$osm_points); nrow(des_bike_and_bridge$osm_lines)
## [1] 7
## [1] 3
</code></pre>

<p>That query returns only 7 points and 3 lines.  Designed cycleways <strong>OR</strong> bridges
can be obtained through simply combining multiple <code>osmdata</code> objects with the <code>c</code>
operator:</p>

<pre><code class="r">q4 &lt;- add_feature(q1, key = &#39;bridge&#39;, value = &#39;yes&#39;)
bridge &lt;- osmdata_sf(q4)
des_bike_or_bridge &lt;- c(des_bike, bridge)
nrow(des_bike_or_bridge$osm_points); nrow(des_bike_or_bridge$osm_lines)
## [1] 208
## [1] 40
</code></pre>

<p>And as expected, the <code>OR</code> operation produces more data than the equivalent
<code>AND</code>, showing the utility of combining <code>osmdata</code> objects with the generic
function <code>c()</code>. </p>

<h2>3. The <code>osmdata</code> object</h2>

<p>The <code>osmdata</code> extraction functions (<code>osmdata_sf()</code> and <code>osmdata_sp()</code>), both
return objects of class <code>osmdata</code>.  The structure of <code>osmdata</code> objects are clear
from their default print method, illustrated using the <code>bridge</code> example from the
previous section:</p>

<pre><code class="r">bridge
##  Object of class &#39;osmdata&#39; with:
##                   $bbox : 37.3002036,-6.0329182,37.4529579,-5.819157
##          $overpass_call : The call submitted to the overpass API
##              $timestamp : [ Thurs 5 May 2017 14:41:19 ]
##             $osm_points : &#39;sf&#39; Simple Features Collection with 69 points
##              $osm_lines : &#39;sf&#39; Simple Features Collection with 25 linestrings
##           $osm_polygons : &#39;sf&#39; Simple Features Collection with 0 polygons
##         $osm_multilines : &#39;sf&#39; Simple Features Collection with 0 multilinestrings
##      $osm_multipolygons : &#39;sf&#39; Simple Features Collection with 0 multipolygons
</code></pre>

<p>As the results show, all <code>osmdata</code> objects should contain:</p>

<ul>
<li>A bounding box (which can be accessed with <code>bridge$bbox</code>)</li>
<li>A time-stamp of the query (<code>bridge$timestamp</code>, useful for checking data is
up-to-date)</li>
<li><p>The spatial data, consisting of <code>osm_points</code>, <code>osm_lines</code>, <code>osm_polygons</code>,
<code>osm_multilines</code> and <code>osm_multipolygons</code>.</p>

<p>hese some or all of these can be empty: the example printed above contains only
points and linesThe more complex features of <code>osm_multilines</code> and
<code>osm_multipolygons</code> refer to OSM relations than contain multiple lines and
polygons.</p></li>
</ul>

<p>The actual spatial data contained in an <code>osmdata</code> object are of either <code>sp</code>
format when extracted with <code>osmdata_sp()</code> or <code>sf</code> format when extracted with
<code>osmdata_sf()</code>. </p>

<pre><code class="r">class(osmdata_sf(q)$osm_lines)
## [1] &quot;sf&quot;         &quot;data.frame&quot;
</code></pre>

<pre><code class="r">class(osmdata_sp(q)$osm_lines)
## [1] &quot;SpatialLinesDataFrame&quot;
## attr(,&quot;package&quot;)
## [1] &quot;sp&quot;
</code></pre>

<p>In addition to these two functions, <code>osmdata</code> provides a third function,
<code>osmdata_xml()</code>, which allows raw OSM data to be returned and optionally saved
to disk in XML format. The following code demonstrates this function, beginning
with a new query.</p>

<pre><code class="r">dat &lt;- opq(bbox = c(-0.12, 51.51, -0.11, 51.52)) %&gt;%
    add_osm_feature(key = &#39;building&#39;) %&gt;%
    osmdata_xml(file = &#39;buildings.osm&#39;)
class(dat)
## [1] &quot;xml_document&quot; &quot;xml_node&quot;
</code></pre>

<p>This call both returns the same data as the object <code>dat</code> and saves them to the
file <code>buildings.osm</code>. Downloaded XML data can be converted to <code>sf</code> or <code>sp</code>
formats by simply passing the data to the respective <code>osmdata</code> functions, either
as the name of a file or an XML object:</p>

<pre><code class="r">q &lt;- opq(bbox = c(-0.12, 51.51, -0.11, 51.52)) %&gt;%
    add_osm_feature(key = &#39;building&#39;)
doc &lt;- osmdata_xml(q, &#39;buildings.osm&#39;)
dat1 &lt;- osmdata_sf(q, doc)
dat2 &lt;- osmdata_sf(q, &#39;buildings.osm&#39;)
identical(dat1, dat2)
## [1] TRUE
</code></pre>

<p>The following sub-sections now explore these three functions in more detail,
beginning with <code>osmdata_xml()</code>.</p>

<h3>3.1. The <code>osmdata_xml()</code> function</h3>

<p><code>osmdata_xml()</code> returns OSM data in native XML format, and also allows these
data to be saved directly to disk (conventionally using the file suffix <code>.osm</code>,
although any suffix may be used). The <code>XML</code> data are formatting using the <code>R</code>
package <code>xml2</code>, and may be processed within <code>R</code> using any methods compatible
with such data, or may be processed by any other software able to load the <code>XML</code>
data directly from disk.</p>

<p>The first few lines of the XML data downloaded above look like this:</p>

<pre><code class="r">readLines(&#39;buildings.osm&#39;)[1:6]
## [1] &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;&quot;                                                                             
## [2] &quot;&lt;osm version=\&quot;0.6\&quot; generator=\&quot;Overpass API\&quot;&gt;&quot;                                                                       
## [3] &quot;  &lt;note&gt;The data included in this document is from www.openstreetmap.org. The data is made available under ODbL.&lt;/note&gt;&quot;
## [4] &quot;  &lt;meta osm_base=\&quot;2017-03-07T09:28:03Z\&quot;/&gt;&quot;                                                                            
## [5] &quot;  &lt;node id=\&quot;21593231\&quot; lat=\&quot;51.5149566\&quot; lon=\&quot;-0.1134203\&quot;/&gt;&quot;                                            
## [6] &quot;  &lt;node id=\&quot;25378129\&quot; lat=\&quot;51.5135870\&quot; lon=\&quot;-0.1115193\&quot;/&gt;&quot;                                                        
</code></pre>

<p>These data can be used in any other programs able to read and process XML data,
such as the open source GIS <a href="http://qgis.org/en/site/">QGIS</a> or the OSM data
editor <a href="http://wiki.openstreetmap.org/wiki/JOSM">JOSM</a>.  The remainder of this
vignette assumes that not only do you want to get OSM data using R, you also
want to import and eventually process it, using R. For that you&#39;ll need to
import the data into a native R class.</p>

<p>As demonstrated above, downloaded data can be directly processed by passing
either filenames or the <code>R</code> objects containing those data to the
<code>osmdata_sf/sp()</code> functions:</p>

<pre><code class="r">dat_sp &lt;- osmdata_sp(q, &#39;buildings.osm&#39;)
dat_sf &lt;- osmdata_sf(q, &#39;buildings.osm&#39;)
</code></pre>

<h3>3.2. The <code>osmdata_sf()</code> function</h3>

<p><code>osmdata_sf()</code> returns OSM data in 
<a href="http://www.opengeospatial.org/standards/sfo">Simple Features (SF)</a> 
format, defined by the
<a href="http://www.opengeospatial.org">Open Geospatial Consortium</a>, and implemented in
the <code>R</code> package <a href="https://cran.r-project.org/package=sf"><code>sf</code></a>. This package
provides a direct interface to the <code>C++</code> 
<a href="http://gdal.org">Graphical Data Abstraction Library (GDAL)</a> which also includes
a so-called <a href="http://www.gdal.org/drv_osm.html">&#39;driver&#39; for OSM data</a>. This
means that OSM data may also be read directly with <code>sf</code>, rather than using
<code>osmdata</code>. In this case, data must first be saved to disk, which can 
be readily achieved using <code>osmdata_xml()</code> described above, or through
downloading directly from the <a href="http://overpass-turbo.eu">overpass interactive query
builder</a>. </p>

<p>The following example is based on this query:</p>

<pre><code class="r">opq(bbox = &#39;Trentham, Australia&#39;) %&gt;%
    add_osm_feature(key = &#39;name&#39;) %&gt;%
    osmdata_xml(filename = &#39;trentham.osm&#39;)
</code></pre>

<p><code>sf</code> can then read such data independent of <code>osmdata</code> though:</p>

<pre><code class="r">sf::st_read(&#39;trentham.osm&#39;, layer = &#39;points&#39;)
## Reading layer `points&#39; from data source `trentham.osm&#39; using driver `OSM&#39;
## Simple feature collection with 38 features and 10 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: 144.2894 ymin: -37.4846 xmax: 144.3893 ymax: -37.36012
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
</code></pre>

<p>The <code>GDAL</code> drivers used by <code>sf</code> can only load single &#39;layers&#39; of features, for
example, <code>points</code>, <code>lines</code>, or <code>polygons</code>. In contrast, <code>osmdata</code> loads all
features simultaneously:</p>

<pre><code class="r">osmdata_sf(q, &#39;trentham.osm&#39;)
## Object of class &#39;osmdata&#39; with:
##                  $bbox : -37.4300874,144.2863388,-37.3500874,144.3663388
##         $overpass_call : The call submitted to the overpass API
##             $timestamp : [ Thus 5 May 2017 14:42:19 ]
##            $osm_points : &#39;sf&#39; Simple Features Collection with 7106 points
##             $osm_lines : &#39;sf&#39; Simple Features Collection with 263 linestrings
##          $osm_polygons : &#39;sf&#39; Simple Features Collection with 38 polygons
##        $osm_multilines : &#39;sf&#39; Simple Features Collection with 1 multilinestrings
##     $osm_multipolygons : &#39;sf&#39; Simple Features Collection with 6 multipolygons
</code></pre>

<p>Even for spatial objects of the same type (the same &#39;layers&#39; in <code>sf</code>
terminology), <code>osmdata</code> returns considerably more objects&ndash;7,166 points compared
.with just 38. The raw sizes of data returned can be compared with:</p>

<pre><code class="r">s1 &lt;- object.size(osmdata_sf(q, &#39;trentham.osm&#39;)$osm_points)
s2 &lt;- object.size(sf::st_read(&#39;trentham.osm&#39;, layer = &#39;points&#39;, quiet = TRUE))
as.numeric(s1 / s2)
## [1] 511.4193
</code></pre>

<p>And the <code>osmdata points</code> contain over 500 times as much data.  The primary
difference between <code>sf/GDAL</code> and <code>osmdata</code> is that the former returns only those
objects unique to each category of spatial object.  Thus OSM nodes (<code>points</code> in
<code>sf/osmdata</code> representations) include, in <code>sf/GDAL</code> representation, only those
points which are not part of any other objects (such as lines or polygons). In
contrast, the <code>osm_points</code> object returned by <code>osmdata</code> includes all points
regardless of whether or not these are represented in other spatial objects.
Similarly, <code>line</code> objects in <code>sf/GDAL</code> exclude any lines that are part of other
objects such as <code>multipolygon</code> or <code>multiline</code> objects.</p>

<p>This processing of data by <code>sf/GDAL</code> has two important implications:</p>

<ol>
<li><p>An implicit hierarchy of spatial objects is enforced through including
elements of objects only at their &#39;highest&#39; level of representation, where
<code>multipolygon</code> and <code>multiline</code> objects are assumed to be at &#39;higher&#39; levels
than <code>polyon</code> or <code>line</code> objects, and these in turn are at &#39;higher&#39; levels than
<code>point</code> objects. <code>osmdata</code> makes no such hierarchical assumptions.</p></li>
<li><p>All OSM are structured by giving each object a unique identifier so that the
components of any given object (the nodes of a line, for example, or the lines
of a multipolygon) can be described simply by giving these identifiers.  This
enables the components of any OSM object to be examined in detail.
The <code>sf/GDAL</code> representation obviates this ability
through removing these IDs and reducing everything to geometries alone (which
is, after all, why it is called &#39;<em>Simple</em> Features&#39;). This means, for example,
that the <code>key-value</code> pairs of the <code>line</code> or <code>polygon</code> components of
<code>multipolygon</code> can never be extracted from an <code>sf/GDAL</code> representation. In
contrast, <code>osmdata</code> retains all unique identifiers for all OSM objects, and so
readily enables, for example, the properties of all <code>point</code> objects of a <code>line</code>
to be extracted.</p></li>
</ol>

<p>Another reason why <code>osmdata</code> returns more data than <code>GDAL/sf</code> is that the latter
extracts only a restricted list of OSM <code>keys</code>, whereas <code>osmdata</code> returns all
<code>key</code> fields present in the requested data:</p>

<pre><code class="r">names(sf::st_read(&#39;trentham.osm&#39;, layer = &#39;points&#39;, quiet = TRUE)) # the keys
## [1] &quot;osm_id&quot;     &quot;name&quot;       &quot;barrier&quot;    &quot;highway&quot;   
## [5] &quot;ref&quot;        &quot;address&quot;    &quot;is_in&quot;      &quot;place&quot;     
## [9] &quot;man_made&quot;   &quot;other_tags&quot; &quot;geometry&quot;  
</code></pre>

<pre><code class="r">names(osmdata_sf(q, &#39;trentham.osm&#39;)$osm_points)
## [1] &quot;osm_id&quot;           &quot;name&quot;             &quot;X_description_&quot;   &quot;X_waypoint_&quot;     
## [5] &quot;addr.city&quot;        &quot;addr.housenumber&quot; &quot;addr.postcode&quot;    &quot;addr.street&quot;     
## [9] &quot;amenity&quot;          &quot;barrier&quot;          &quot;denomination&quot;     &quot;foot&quot;            
## [13] &quot;ford&quot;             &quot;highway&quot;          &quot;leisure&quot;          &quot;note_1&quot;          
## [17] &quot;phone&quot;            &quot;place&quot;            &quot;railway&quot;          &quot;railway.historic&quot;
## [21] &quot;ref&quot;              &quot;religion&quot;         &quot;shop&quot;             &quot;source&quot;          
## [25] &quot;tourism&quot;          &quot;waterway&quot;         &quot;geometry&quot; 
</code></pre>

<p><code>key</code> fields which are not specified in a given set of OSM data are not returned
by <code>osmdata</code>, while <code>GDAL/sf</code> returns the same <code>key</code> fields regardless of
whether any values are specified.</p>

<pre><code class="r">addr &lt;- sf::st_read(&#39;trentham.osm&#39;, layer = &#39;points&#39;, quiet = TRUE)$address
all(is.na(addr))
## TRUE
</code></pre>

<p>and <code>key=address</code> contains no data yet is still returned by <code>GDAL/sf</code>.</p>

<p>Finally, note that <code>osmdata</code> will generally extract OSM data considerably faster
than equivalent <code>sf/GDAL</code> routines (as detailed
<a href="https://github.com/osmdatar/osmdata/wiki/Timing-benchmarks">here</a>).</p>

<h3>3.3. The <code>osmdata_sp()</code> function</h3>

<p>As with <code>osmdata_sf()</code> described above, OSM data may be converted to <code>sp</code>
format without using <code>osmdata</code> via the <code>sf</code> functions demonstrated below: </p>

<pre><code class="r">dat &lt;- sf::st_read(&#39;buildings.osm&#39;, layer = &#39;multipolygons&#39;, quiet = TRUE)
dat_sp &lt;- as(dat, &#39;Spatial&#39;)
class(dat_sp)
## [1] &quot;SpatialPolygonsDataFrame&quot;\nattr(,&quot;package&quot;)\n[1] &quot;sp&quot;
</code></pre>

<p>These data are extracted using the GDAL, and so suffer all of the same
shortcomings mentioned above. Note differences in the amount of data returned:</p>

<pre><code class="r">dim(dat_sp)
## [1] 560  25
</code></pre>

<pre><code class="r">dim(osmdata_sp(q, doc = &#39;buildings.osm&#39;)$osm_polygons)
## [1] 566 114
</code></pre>

<pre><code class="r">dim(osmdata_sp(q, doc = &#39;buildings.osm&#39;)$osm_multipolygons)
## [1] 15 52
</code></pre>

<h2>4. Recursive searching</h2>

<p>As described above, <code>osmdata</code> returns all data of each type and so allows the
components of any given spatial object to be examined in their own right.  This
ability to extract, for example, all points of a line, or all polygons which
include a given set of points, is referred to as <em>recursive searching</em>.</p>

<p>Recursive searching is not possible with <code>GDAL/sf</code>, because OSM identifiers are
removed, and only the unique data of each type of object are retained. To
understand both recursive searching and why it is useful, note that OSM data are
structured in three hierarchical levels:</p>

<ol>
<li><p><code>nodes</code> representing spatial points </p></li>
<li><p><code>ways</code> representing lines, both as <code>polygons</code> (with connected ends) and
non-polygonal <code>lines</code></p></li>
<li><p><code>relations</code> representing more complex objects generally comprising
collections of <code>ways</code> and/or <code>nodes</code>. Examples include 
<code>multipolygon relations</code> comprising an outer polygon (which may itself be
made of several distinct <code>ways</code> which ultimately connect to form a single
circle), and several inner polygons.</p></li>
</ol>

<p>Recursive searching allows for objects within any one of these hierarchical
levels to be extracted based on components in any other level. Recursive
searching is performed in <code>osmdata</code> with the following functions:</p>

<ol>
<li><p><code>osm_points()</code>, which extracts all <code>point</code> or <code>node</code> objects </p></li>
<li><p><code>osm_lines()</code>, which extracts all <code>way</code> objects that are <code>lines</code> (that are, that are
not <code>polygons</code>) </p></li>
<li><p><code>osm_polygons()</code>, which extracts all <code>polygon</code> objects</p></li>
<li><p><code>osm_multilines()</code>, which extracts all <code>multiline</code> objects; and</p></li>
<li><p><code>osm_multipolygons()</code>, which extracts all <code>multipolygon</code> objects.</p></li>
</ol>

<p>Each of these functions accepts as an argument a vector of OSM identifiers. To
demonstrate these functions, we first re-create the example above of named
objects from Trentham, Australia:</p>

<pre><code class="r">tr &lt;- opq(bbox = &#39;Trentham, Australia&#39;) %&gt;%
    add_osm_feature(key = &#39;name&#39;) %&gt;%
    osmdata_sf()
</code></pre>

<h3>4.1. Example</h3>

<p>Then imagine we are interested in the <code>osm_line</code> object describing the &#39;Coliban
River&#39;:</p>

<pre><code class="r">i &lt;- which(tr$osm_lines$name == &#39;Coliban River&#39;)
coliban &lt;- tr$osm_lines[i, ]
coliban[which(!is.na(coliban))]
## Simple feature collection with 1 feature and 3 fields
## geometry type:  LINESTRING
## dimension:      XY
## bbox:           xmin: 144.3235 ymin: -37.37162 xmax: 144.3335 ymax: 37.36366
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
##            osm_id          name waterway                       geometry
## 87104907 87104907 Coliban River    river LINESTRING(144.323471069336...
</code></pre>

<p>The locations of the points of this line can be extracted directly from the <code>sf</code>
object with:</p>

<pre><code class="r">coliban$geometry[[1]]
## LINESTRING(144.323471069336 -37.3716201782227, 144.323944091797 -37.3714790344238, 144.324356079102 -37.3709754943848, 144.324493408203 -37.3704833984375, 144.324600219727 -37.370174407959, 144.324981689453 -37.3697204589844, 144.325149536133 -37.369441986084, 144.325393676758 -37.3690567016602, 144.325714111328 -37.3686943054199, 144.326080322266 -37.3682441711426)
</code></pre>

<p>The output contains nothing other than geometries (because, to reiterate, these
are &#39;<em>Simple</em> Features&#39;), and no further information regarding those points can
be extracted. The Coliban River has a waterfall in Trentham, and one of the
<code>osm_points</code> objects describes this waterfall.  The information necessary to
locate this waterfall is removed from the <code>GDAL/sf</code> representation, but can be
extracted with <code>osmdata</code> with the following lines, noting that the 
OSM ID of the line <code>coliban</code> is given by <code>rownames(coliban)</code>.</p>

<pre><code class="r">pts &lt;- osm_points(tr, rownames(coliban))
wf &lt;- pts[which(pts$waterway == &#39;waterfall&#39;), ]
wf[which(!is.na(wf))]
## Simple feature collection with 1 feature and 4 fields
## geometry type:  POINT
## dimension:      XY
## bbox:           xmin: 144.3246 ymin: -37.37017 xmax: 144.3246 ymax: -37.37017
## epsg (SRID):    4326
## proj4string:    +proj=longlat +datum=WGS84 +no_defs
##                osm_id           name    tourism  waterway
## 1013064837 1013064837 Trentham Falls attraction waterfall
##                                  geometry
## 1013064837 POINT(144.324600219727 -37....
</code></pre>

<p>This point could be used as the basis for further recursive searches. For
example, all <code>multipolygon</code> objects which include Trentham Falls could be
extracted with:</p>

<pre><code class="r">mp &lt;- osm_multipolygons(tr, rownames(wf))
</code></pre>

<p>Although this returns no data in this case, it nevertheless demonstrates the
usefulness and ease of recursive searching with <code>osmdata</code>.</p>

<h3>4.2 Relation example</h3>

<p>A special type of OSM object is a relation. These can be defined by their name,
which can join many divers features into a single object.
The following example extracts the London Route Network Route 9,
which is composed of many (over 100) separate lines:</p>

<pre><code class="r">lcnr9 &lt;- opq (&#39;greater london uk&#39;) %&gt;%
    add_osm_feature (key = &quot;name&quot;, value = &quot;LCN 9&quot;,
                 value_exact = FALSE) %&gt;%
    osmdata_sp()
sp::plot(lcnr9$osm_lines)
</code></pre>

<p><img src="https://cloud.githubusercontent.com/assets/1825120/23709879/c98e2c2c-0412-11e7-86b8-1ffc95aab5a1.png" alt=""/></p>

<h2>5. Related Packages</h2>

<p>@eugster_osmar:_2012 describe <code>osmar</code>, an R package for handling OSM data
that enables visualisation, search and even rudimentary routing operations.
<code>osmar</code> is not user friendly or able to download OSM data flexibly,
as reported in an <a href="http://eprints.whiterose.ac.uk/77643/">early tutorial</a>
comparing R and QGIS for handling OSM data [@lovelace_harnessing_2014].</p>

<p><code>osmdata</code> builds on two previous R packages:
<code>osmplotr</code>, a package <a href="https://cran.r-project.org/package=osmplotr">available from CRAN</a>
for accessing and plotting OSM data [@osmplotr]
and <code>overpass</code>, a <a href="https://github.com/hrbrmstr/overpass">GitHub package</a>
by Bob Rudis that provides an R interface to the 
<a href="http://overpass-api.de/">overpass</a> API.</p>

<h2>6. References</h2>

</body>

</html>
